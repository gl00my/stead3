## Модули STEAD3

Данное руководство описывает основы разработки модулей
STEAD3. Поэтому в дальнейшем изложении слово "модуль" означает именно
модуль написанный в рамках STEAD3.

Что такое модуль? Часто ошибочно считают, что модуль -- это любой
отдельный файл игры, содержащий служебные функции, структуры и
объекты. На самом деле это не так. Если вам необходимо выделить
служебный код в отдельные игровые файлы так, чтобы он выполнялся в
момент старта игры -- вам достаточно включить такой файл инструкцией
include:

    include "mylib"


Модули stead3 пишутся следуя специальным соглашениям, при нарушении
которых вы получите нерабочую игру. Данные соглашения и описываются в
этом руководстве. Очень часто в оформлении своего кода в виде модуля
просто нет никакой необходимости. Написание модуля целесообразно в тех
случаях, когда требуемая функциональность может быть реализована за
счет тесного взаимодействия с движком STEAD3 и представляет ценность
не только в рамках вашей игры. Примерами модулей могут быть:

- модуль форматирования вывода;
- модуль нестандартного управления игрой;
- модуль генерации изображений нотного стана...

И так далее.

## Игровой мир

Важным отличием модуля от просто библиотечного файла является время
жизни модуля. Игровой мир (объект game, игрок, все объекты и
переменные игры) создается в момент запуска игры. При
подгрузке частей игры с помощью gamefile, а также при загрузке
сохранений игры -- игровой мир уничтожается, чтобы затем снова
создаться заново. В момент уничтожения мира, все созданные объекты и
переменные перестают существовать.

Когда вы включаете код с помощью include, весь этот код будет
выполнятся в момент каждого создания мира. Обычно, это подразумевается
автором как само собой разумеющееся поведение. Но в случае модуля, это
не так!

Модуль загружается один раз, во время создания игровой сессии и
существует все то время, пока выполняется игровой код. То есть, после
уничтожении игрового мира и при его новом создании, уже загруженные ранее
модули не загружаются повторно.

Это означает, например, что в модуле _нельзя_ определять глобальные
переменные, объекты и комнаты так, как это делается в обычном коде
игры. Например, модуль не может содержать строки вида:

    -- мой неправильный модуль
    global 'MYVAR' (10);
    room { nam = 'комната'; };

Дело в том, что и MYVAR и комната будут уничтожены при первой же
загрузки игры из файла сохранения, так как игровой мир уничтожается
целиком, а переменная MYVAR и комната -- часть этого игрового мира.

Если подумать, это становится понятным с той точки зрения, что модуль
не должен в общем случае создавать какие-то объекты и глобальные
переменные в игровом мире игры. Ведь модуль может работать с любой
игрой, и не должен учитывать особенности игрового мира конкретной игры.

Создание глобальных функций тоже не является хорошим тоном при
написании модулей. Если вам нужна служебная функция в рамках самого
модуля, объявляйте ее с local (то же касается и переменных):

```
local A = 10
local function myfunc(a, b)
    return (a * b) / A
end
```

Тогда такая функция будет доступна в рамках модуля.

## Системный объект как интерфейс

После прочтения прошлой главы мог возникнуть резонный вопрос. Если все
переменные и объекты модуля уничтожаются -- то как вообще
взаимодействовать с модулем? Если модуль должен предоставлять
какой либо интерфейс, а также сохранять свое состояние, то в модуле
следует создать системный объект (чье имя начинается с символа
'@'). Подробнее про системные объекты можно прочитать в документации
STEAD3. Важно то, что такие объекты _не уничтожаются_ в процессе
смерти мира, и таким образом играют роль интерфейса к
модулю. Например:

```
-- модуль testmod.lua
obj {
    nam = '@testmod';
    hello = function(s)
        dprint("Hello world");
    end;
}
```

Такой модуль уже можно использовать:

```
loadmod 'testmod'
_'@testmod'.hello() -- получили объект '@testmod' и вызвали метод hello()

```
Но это не слишком удобно. Следующий вариант модуля:

```
-- модуль mymodule.lua
local mod = obj { -- локальная ссылка на объект
    nam = '@testmod';
}

function mod.hello(a) -- вариант определения метода вне объекта
    dprint("Hello world")
end

testmod = mod -- глобальный объект testmod -- интерфейс к модулю
```

Использование модуля:

```
loadmod 'testmod'
testmod.hello()

```

Сделаем вариант модуля с переменной, которая должна сохранятся:

```
-- модуль mymodule.lua
local mod = obj { -- локальная ссылка на объект
    nam = '@testmod';
    num = 0; -- переменная
}

function mod.hello(a)
    dprint("Hello world", mod.num)
    mod.num = mod.num + 1
end

testmod = mod -- глобальный объект testmod -- интерфейс к модулю
```
Обратите внимание, что последний вариант можно сделать и так:

```
-- модуль mymodule.lua
local mod = obj { -- локальная ссылка на объект
    nam = '@testmod';
    num = 0; -- переменная
}

function mod:hello(a)
    dprint("Hello world", self.num) -- обратите внимание на :
    -- в mod:hello и self
    self.num = self.num + 1
end

testmod = mod -- глобальный объект testmod -- интерфейс к модулю
```
Использование модуля в таком случае:

```
loadmod 'testmod'
testmod:hello() -- обратите внимание на : между testmod и hello
-- это означает testmod.hello(testmod)

```

Итак, подводя итоги:

- интерфейсом к модулю служит системный объект, имя которого совпадает
  с именем модуля;
- все переменные, которые нужно сохранять, должны быть переменными
  этого  объекта;
- вы можете вызывать методы через модуль.метод() или модуль:метод(),
  во втором случае, первым параметром будет объект - интерфейс.

## События

TODO
