## Модули STEAD3

Данное руководство описывает основы разработки модулей
STEAD3. Поэтому в дальнейшем изложении слово "модуль" означает именно
модуль написанный в рамках STEAD3.

Что такое модуль? Часто ошибочно считают, что модуль -- это любой
отдельный файл игры, содержащий служебные функции, структуры и
объекты. На самом деле это не так. Если вам необходимо выделить
служебный код в отдельные игровые файлы так, чтобы он выполнялся в
момент старта игры -- вам достаточно включить такой файл инструкцией
include:

    include "mylib"


Модули stead3 пишутся следуя специальным соглашениям, при нарушении
которых вы получите нерабочую игру. Данные соглашения и описываются в
этом руководстве. Очень часто в оформлении своего кода в виде модуля
просто нет никакой необходимости. Написание модуля целесообразно в тех
случаях, когда требуемая функциональность может быть реализована за
счет тесного взаимодействия с движком STEAD3 и представляет ценность
не только в рамках вашей игры. Примерами модулей могут быть:

- модуль форматирования вывода;
- модуль нестандартного управления игрой;
- модуль генерации изображений нотного стана...

И так далее.

## Игровой мир

Важным отличием модуля от просто библиотечного файла является время
жизни модуля. Игровой мир (объект game, игрок, все объекты и
переменные игры) создается в момент запуска игры. При
подгрузке частей игры с помощью gamefile, а также при загрузке
сохранений игры -- игровой мир уничтожается, чтобы затем снова
создаться заново. В момент уничтожения мира, все созданные объекты и
переменные перестают существовать.

Когда вы включаете код с помощью include, весь этот код будет
выполнятся в момент каждого создания мира. Обычно, это подразумевается
автором как само собой разумеющееся поведение. Но в случае модуля, это
не так!

Модуль загружается один раз, во время создания игровой сессии и
существует все то время, пока выполняется игровой код. То есть, после
уничтожении игрового мира и при его новом создании, уже загруженные ранее
модули не загружаются повторно.

Это означает, например, что в модуле _нельзя_ определять глобальные
переменные, объекты и комнаты так, как это делается в обычном коде
игры. Например, модуль не может содержать строки вида:

    -- мой неправильный модуль
    global 'MYVAR' (10);
    room { nam = 'комната'; };

Дело в том, что и MYVAR и комната будут уничтожены при первой же
загрузки игры из файла сохранения, так как игровой мир уничтожается
целиком, а переменная MYVAR и комната -- часть этого игрового мира.

Если подумать, это становится понятным с той точки зрения, что модуль
не должен в общем случае создавать какие-то объекты и глобальные
переменные в игровом мире игры. Ведь модуль может работать с любой
игрой, и не должен учитывать особенности игрового мира конкретной игры.

Создание глобальных функций тоже не является хорошим тоном при
написании модулей. Если вам нужна служебная функция в рамках самого
модуля, объявляйте ее с local (то же касается и переменных):

```
local A = 10
local function myfunc(a, b)
    return (a * b) / A
end
```

Тогда такая функция будет доступна в рамках модуля.

## Системный объект как интерфейс

После прочтения прошлой главы мог возникнуть резонный вопрос. Если все
переменные и объекты модуля уничтожаются -- то как вообще
взаимодействовать с модулем? Если модуль должен предоставлять
какой либо интерфейс, а также сохранять свое состояние, то в модуле
следует создать системный объект (чье имя начинается с символа
'@'). Подробнее про системные объекты можно прочитать в документации
STEAD3. Важно то, что такие объекты _не уничтожаются_ в процессе
смерти мира, и таким образом играют роль интерфейса к
модулю. Например:

```
-- модуль testmod.lua
obj {
    nam = '@testmod';
    hello = function(s)
        dprint("Hello world");
    end;
}
```

Такой модуль уже можно использовать:

```
loadmod 'testmod'
_'@testmod'.hello() -- получили объект '@testmod' и вызвали метод hello()

```
Но это не слишком удобно. Следующий вариант модуля:

```
-- модуль mymodule.lua
local mod = obj { -- локальная ссылка на объект
    nam = '@testmod';
}

function mod.hello(a) -- вариант определения метода вне объекта
    dprint("Hello world")
end

testmod = mod -- глобальный объект testmod -- интерфейс к модулю
```

Использование модуля:

```
loadmod 'testmod'
testmod.hello()

```

Сделаем вариант модуля с переменной, которая должна сохранятся:

```
-- модуль mymodule.lua
local mod = obj { -- локальная ссылка на объект
    nam = '@testmod';
    num = 0; -- переменная
}

function mod.hello(a)
    dprint("Hello world", mod.num)
    mod.num = mod.num + 1
end

testmod = mod -- глобальный объект testmod -- интерфейс к модулю
```
Обратите внимание, что последний вариант можно сделать и так:

```
-- модуль mymodule.lua
local mod = obj { -- локальная ссылка на объект
    nam = '@testmod';
    num = 0; -- переменная
}

function mod:hello(a)
    dprint("Hello world", self.num) -- обратите внимание на :
    -- в mod:hello и self
    self.num = self.num + 1
end

testmod = mod -- глобальный объект testmod -- интерфейс к модулю
```
Использование модуля в таком случае:

```
loadmod 'testmod'
testmod:hello() -- обратите внимание на : между testmod и hello
-- это означает testmod.hello(testmod)

```

Итак, подводя итоги:

- интерфейсом к модулю служит системный объект, имя которого совпадает
  с именем модуля;
- все переменные, которые нужно сохранять, должны быть переменными
  этого  объекта;
- вы можете вызывать методы через модуль.метод() или модуль:метод(),
  во втором случае, первым параметром будет объект - интерфейс.

## События

Итак, модуль существует все время жизни игровой сессии, во время
которой игровой мир может неоднократно уничтожаться и создаваться
снова. Допустим, автору модуля необходимо выполнять какие то действия
в момент создания игрового мира (например, помещать что то в инвентарь
игрока). Как это сделать? Модуль может регистрировать специальные
функции-обработчики некоторых событий. Например, для отслеживания
события "создание игрового мира", мы регистрируем обработчик init:

```
std.mod_init(function()
        declare {
                game = std.ref 'game',
                pl = std.ref 'player',
        }
end)
```

Приведенный код -- инициализация стандартной библиотеки stdlib из
STEAD3. Как видим, тут происходит объявление переменных-ссылок game и
pl для удобства работы с этими объектами.


Итак, регистрация обработчика выполняется с помощью вызова:

```
std.mod_тип_события(функция, [приоритет])
```

Параметр [приоритет] (чем меньше -- тем приоритетней) является
необязательным и определяет порядок вызова вашей функции относительно
других функций для данного события, например:


```
local function init()
      dprint("Очень ранний init");
end
std.mod_init(init, -10);
```

Перечислим все события, для которых можно зарегистрировать свой
обработчик.

- init - инициализация мира. В обработчик придет параметр load (true
  -- если это загрузка из файла сохранения). Вызывается перед init() игры;
- done - деинициализация мира;
- start - запуск игры после инициализации мира (непосредственно перед
  вызовом start() игры);
- cmd - вызывается перед выполнением команды. Если вернет не nil --
  воспринимается движком как реакция на команду. В качестве параметра
  - массив (команда, параметр1, параметр2, ...);
- step - вызывается после выполнения команды. В качестве параметра --
  true (команда выполнена), или false (ошибочная команда); Выполняется
  перед game:step();
- save - вызывается после сохранения динамических объектов игры в файл
  сохранения. В качестве параметра -- указатель на файл сохранения (Lua).

## Классы

Все объекты в INSTEAD, кроме переменных, атрибутов и обработчиков
содержат методы (функции), которые вызываются при работе движка.

Когда в коде вашей игры, вы пишете что то вроде:

````
obj {
    nam = 'стол';
    dsc = "Тут стоит {стол}.";
}
````

То вы создаете таблицу Lua, в которой кроме nam и dsc определены
многие другие вещи. Например, метод disable(). Когда вы пишете:

````
obj {
    nam = 'стол';
    dsc = "Тут стоит {стол}.";
}:disable()
````

Вы у созданного только что объекта, вызываете метод
disable(). (Вызывается функция disable вашего объекта и в качестве
1-го параметра передается этот ваш объект).

На самом деле, когда вы создаете объект с помощью obj, вы неявно
вызываете метод (функцию) new у класса obj.

Классы, удобный способ описать иерархию объектов INSTEAD, а так же
реализовать свои типы объектов. Например, вот как определяется класс
obj (с сокращениями):

````
std.obj = std.class { -- определяем класс
	__obj_type = true; -- тип объектов (функция is_obj)
	with = function(self, ...)
	     -- ... реализация конструкции :with
	end;
	new = function(self, v)
	    -- реализация конструктора obj { }
	end;
	-- другие методы
	-- ...
	display = function(self) -- отображение объекта
		local d = std.call(self, 'dsc')
		return d
	end;
	-- другие методы
	-- ...
};


````
Обратите внимание на метод display, этот метод служит для отображения
объекта в сцене. Как видите, он просто вызывает 'dsc' у объекта, с
помощью std.call (вызов функции или строки).

Теперь представим себе, что вы хотите сделать класс объектов, у
которых в темноте пропадает описатель. Признаком темноты является
переменная darkroom в текущей комнате, тогда:


````
darkobj = std.class ({ -- определяем класс
	__darkobj_type = true; -- тип объектов (функция is_obj)
	display = function(self) -- отображение объекта
		if not here().darkroom then
			local d = std.call(self, 'dsc')
			return d
		end
	end;
}, std.obj);


darkobj {
	nam = 'кот';
	dsc = '{Кот} виден при свете.'
}
````

Обратите внимение на скобки () и std.obj в последней строке. Таким
образом мы дали понять, что наследуемся от класса std.obj. Все
методы объекта, созданного при помощи darkobj, будут такими же как и у
obj, кроме метода display().

Если говорить об иерархии объектов STEAD3, то:

- room пронаследован от obj;
- dlg пронаследован от room;
- std.phr (фразы) пронаследован от obj;

std.dlg, std.room, std.phr и std.obj это внутренние имена классов. В
стандартной библиотеке stdlib, которая включается в вашу игру,
определены такие переменные;


````
local std = stead
local type = std.type
std.rawset(_G, 'std', stead) -- определим std для всех
include = std.include
loadmod = std.loadmod
rnd = std.rnd
rnd_seed = std.rnd_seed
p = std.p
pr = std.pr
pn = std.pn
pf = std.pf
obj = std.obj
stat = std.stat
room = std.room
menu = std.menu
dlg = std.dlg
me = std.me
here = std.here
from = std.from
new = std.new
delete = std.delete
-- nameof = std.nameof
-- dispof = std.dispof
-- titleof = std.titleof
gamefile = std.gamefile
player = std.player
dprint = std.dprint
````

Это сделано для удобства автора (легче написать include, вместо
std.include и так далее). Если же вы разрабатываете свой _модуль_, то
рекомендуется пользоваться внутренними именами с префиксом std. Причем
std определять в начале модуля как:

````
local std = stead
````

Это обезопасит ваш модуль от коллизий с игровыми глобальными переменными.

## Цикл обработки команд

TODO